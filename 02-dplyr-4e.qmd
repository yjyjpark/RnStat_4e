# 데이터 프레임 다루기 {#sec-data-frame-handling}


## 데이터 프레임 {#sec-dataframe}


## 패키지 dplyr에 의한 데이터 프레임 다루기 {#sec-dplyr}


## 연습문제


**3.** 데이터 프레임  `iris`는 세 가지 붓꽃 `setosa`, `versicolor`, `virginica`의 꽃잎과 꽃받침의 길이와 폭을 측정한 자료이다.

```{r}
#| echo: false
library(tidyverse)
```


1\)\ 변수 `Species`가 `setosa`인 붓꽃만 선택해서 변수 `Petal.Length`의 오름차순으로 재배열하라. 변수 `Petal.Length`의 값이 같은 경우에는 변수 `Petal.Width`의 값이 큰 자료부터 배열하라. 


```{r}
  iris |> 
  filter(Species == "setosa") |> 
  arrange(Petal.Length, desc(Petal.Width))
```
   

2\)\ 붓꽃 `setosa` 중에 변수 `Petal.Length`가 1 이하고, `Petal.Width`가 0.5 이하인 붓꽃이 몇 송이가 되는지 확인해 보자.


```{r}
iris |> 
  filter(Species == "setosa") |> 
  filter(Petal.Length <= 1 & Petal.Width <= 0.5) |> 
  nrow()
```


3\)\ 변수 `Species`가 `setosa`인 붓꽃 중에 변수 `Petal.Length`의 값이 가장 큰 붓꽃 자료를 출력해 보자.

```{r}
iris |> 
  filter(Species == "setosa") |> 
  slice_max(Petal.Length)
```


4\)\ 붓꽃 `versicolor`와 `virginica` 중에 `Petal.Length`와 `Petal.Width`의 합이 가장 큰 붓꽃 자료를 출력해 보자.

```{r}
iris |> 
  filter(Species %in% c("versicolor", "virginica")) |> 
  slice_max(Petal.Length + Petal.Width)
```


5\)\ 붓꽃 `setosa` 중에 `Petal.Length`와 `Petal.Width`의 합이 가장 작은 붓꽃 자료를 출력해 보자. 


```{r}
iris |> 
  filter(Species == "setosa") |> 
  slice_min(Petal.Length + Petal.Width)
```



**5.** 패키지  `MASS`의 데이터 프레임 `Cars93`는 1993년 미국에서 판매된 93종류 자동차에 대한 자료가 입력되어 있는 전통적 데이터 프레임이다. 

1\)\  `Cars93`의 모든 변수의 처음 3행 자료를 `tibble`의 형식으로 출력하라.
   
```{r}
data(Cars93, package = "MASS")
as_tibble(Cars93) |> 
  print(n = 3, width = Inf)
```

   
2\)\   변수 `Manufacturer`, `Model`, `Cylinders`, `Man.trans.avail`, `MPG.highway`, `EngineSize`를 선택해서 데이터 프레임 `cars_93`에 입력하라. 

```{r}
cars_93 <- Cars93 |> 
  select(Manufacturer, Model, Cylinders, Man.trans.avail, MPG.highway, EngineSize)
```
   
   
3\)\  데이터 프레임 `cars_93`에서 변수 `Manufacturer`과 `Model`을 결합해서 `maker`를 생성하고, 첫 번째 변수로 위치를 이동하라. 변수 `Manufacturer`과 `Model`은 `cars_93`에서 삭제한다.

```{r}
cars_93 <- cars_93 |> 
  mutate(maker = paste(Manufacturer, Model), .before = Manufacturer) |> 
  select(!c(Manufacturer, Model))
```


4\)\  `cars_93`의 변수 중 `Cylinders`는 `cyl`로, `Man.trans.avail`은 `trans`로, `MPG.highway`는 `hwy`로, `EngineSize`는 `displ`로 각각 이름을 변경하라.

```{r}
cars_93 <- cars_93 |> 
  rename(cyl = Cylinders, trans = Man.trans.avail, hwy = MPG.highway, displ = EngineSize)
```

   
5\)\  `cars_93`에서 숫자형 변수만을 선택해서 처음 5개 행을 출력하라. 

```{r}
cars_93 |> 
  select(where(is.numeric)) |> 
  slice_head(n = 5)
```
   
   
6\)\  `cars_93`에서 변수 `cyl`로 구분되는 그룹별로 해당되는 자동차의 대수를 구하라.
 
```{r}
cars_93 |> 
  count(cyl)
```
  

7\)\  변수 `cyl`이 `3`, `5`, `rotary`가 되는 빈도가 높지 않다. `cars_93`에서 해당되는 자동차의 자료를 삭제하라. 

```{r}
cars_93 <- cars_93 |> 
  filter(!cyl %in% c("3", "5", "rotary") )
```

   
8\)\ `cars_93`에서 `hwy`의 값이 가장 큰 자동차의 자료를 출력하라.

```{r}
cars_93 |> 
  slice_max(hwy)
```

   
9\)\  `cars_93`에서 변수 `cyl`로 구분되는 그룹별로 `hwy`의 값이 가장 큰 자동차의 자료를 출력하라.

```{r}
cars_93 |> 
  group_by(cyl) |> 
  slice_max(hwy)
```



   
**7.** 데이터 프레임  `airquality`는 뉴욕의 오존 농도에 관한 자료로서 6개 열, 153개 행으로 구성되어 있으다. 

1\)\ 변수 `Ozone`에는 많은 수의 결측값이 있다. 월별 겵측값의 수와 비율을 다음과 같이 출력하라. 
   
```{r}
#| echo: false
airquality |> 
  group_by(Month) |> 
  summarise(oz_na = sum(is.na(Ozone)), oz_na_prop = oz_na / n())
```


```{r}
airquality |> 
  group_by(Month) |> 
  summarise(oz_na = sum(is.na(Ozone)), oz_na_prop = oz_na / n())
```


2\)\ 변수 `Solar.R`에도 많은 수의 결측값이 있다. 변수 `Ozone`과 `Solar.R` 중 적어도 한 변수가 결측값을 갖는 날수를 월별로 계산하라. 


```{r}
airquality |> 
  group_by(Month) |> 
  summarise(n_na = sum(is.na(Ozone) | is.na(Solar.R)))
```

   
3\)\  변수 `Wind`의 값이 `mean(Wind)` 이상이고, 변수 `Temp`의 값이 `mean(Temp)` 미만이 되는 행을 선택해서, 데이터 프레임 `air_sub1`에 할당하라.

```{r}
air_sub1 <- airquality |> 
  filter(Wind >= mean(Wind) & Temp <= mean(Temp))
```


4\)\  변수 `Wind`의 값이 `mean(Wind)` 미만이고, 변수 `Temp`의 값이 `mean(Temp)` 이상이 되는 행을 선택해서, 데이터 프레임 `air_sub2`에 할당하라.
   
```{r}
air_sub2 <- airquality |> 
  filter(Wind <= mean(Wind) & Temp >= mean(Temp))
```


5\)\  `air_sub1`과 `air_sub2`의 변수 `Ozone`과 `Solar.R`의 평균값 및 중앙값을 계산해서 비교하라. 

```{r}
air_sub1 |> 
  summarise(m_oz = mean(Ozone, na.rm = TRUE), 
            med_oz = median(Ozone, na.rm = TRUE),
            m_sol = mean(Solar.R, na.rm = TRUE),
            med_sol = median(Solar.R, na.rm = TRUE))
```

```{r}
air_sub2 |> 
  summarise(m_oz = mean(Ozone, na.rm = TRUE), 
            med_oz = median(Ozone, na.rm = TRUE),
            m_sol = mean(Solar.R, na.rm = TRUE),
            med_sol = median(Solar.R, na.rm = TRUE))
```


6\)\  `air_sub1`과 `air_sub2`의 변수 `Ozone`과 `Solar.R`의 월별 평균값 및 해당 날짜 수를 계산해서 비교하라. 

```{r}
air_sub1 |> 
  group_by(Month) |> 
  summarise(m_oz = mean(Ozone, na.rm = TRUE), 
            m_sol = mean(Solar.R, na.rm = TRUE),
            n = n())
```

```{r}
air_sub2 |> 
  group_by(Month) |> 
  summarise(m_oz = mean(Ozone, na.rm = TRUE), 
            m_sol = mean(Solar.R, na.rm = TRUE),
            n = n())
```


**8.** 다음의 표는 세 명의 영업사원이 한 달간 판매한 세 가지 품목의 판매량 자료라고 한다. 


```{r}
#| echo: false
library(flextable)
library(officer)
my_border <- fp_border(color = "gray", width = 1)
data.frame(Name = c("Park", "Lee", "Kim"), A = c(14, 21, 15), 
           B = c(12, 16, 5), C = c(4, 8, 10)) |> 
  flextable() |> 
  add_header_row(values = c("", "Item"),
                 colwidths = c(1, 3)) |> 
  align(i = 1, part = "header", align = "center") |> 
  set_table_properties(layout = "autofit") |> 
  bold(i = 1, j = 2, part = "header") |> 
  bold(i = 2, j = 1, part = "header") |> 
  paginate() |> 
  vline(j = 1, border = my_border)
```


각 영업사원별 총 판매량을 구해서 다음과 같이 출력하라. 

```{r}
#| echo: false
df29 <- tibble(name = c("Park", "Lee", "Kim"),
               A = c(14, 21, 15), B = c(12, 16, 5),
               C = c(4, 8, 10))
df29 |> 
  rowwise() |> 
  mutate(total = sum(c_across(A:C))) |> 
  ungroup()
```

```{r}
tibble(name = c("Park", "Lee", "Kim"),
               A = c(14, 21, 15), B = c(12, 16, 5),
               C = c(4, 8, 10)) |> 
  rowwise() |> 
  mutate(total = sum(c_across(A:C))) |> 
  ungroup()
```



{{< pagebreak >}}










